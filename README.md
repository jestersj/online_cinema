# Справочник фильмов и сериалов

## Как запустить

#### Windows (Powershell)

```
($env:TOKEN = "ваш_токен") -and (npm run start)
```

#### Windows (cmd.exe)

```
set "TOKEN=ваш_токен" && npm run start
```

#### Linux, macOS (Bash)

```
TOKEN=ваш_токен npm run start
```

После запуска проект будет доступен по ссылке [http://localhost:7070](http://localhost:7070)


## Стек

1. Typescript
2. React
3. Webpack (отконфигурирован с нуля, не через create-react-app)
4. React-router-dom
5. Redux

## Дополнительные фичи 
1. Наличие авторизации (проверка пароля захардкожена. 
Логин - любой, **пароль - 123**)
2. Реализована страница c поиском рандомного фильма
3. Реализована возможность поделиться результатами 
выдачи с другими пользователями через копирование ссылки
4. Сохраняется история поиска (последние 20 запросов, запись происходит в localStorage)
5. При вводе нового названия появляется 
suggest с предложениями из ранее введенных значений
6. При вводе значений происходит фильтрация подсказок по вхождению
7. При поиске есть debounce в 1 секунду

## Возникшие проблемы

1. На странице конкретного фильма для получения данных используются разные запросы, и передо мной встал вопрос, как грамотно это реализовать. 
От идеи с async/await я сразу отказался, так как в таком случае следующий запрос отравится не параллельно с предыдущем, а
после того, как придет результат предыдущего.
Promise.all не подходит, так как если один запрос вернется с ошибкой отвалятся все, 
Promise.allSettled не во всех браузерах поддерживается. В целом оба этих варианта ждут выполнения всех запросов, а в процессе работы
я заметил, что одни запросы могут выполнятся значительней быстрее других.
Поэтому я просто сделал несколько промисов, пожертвовав немного красотой кода и сделав подгрузку разных частей страницы параллельной 
2. Во время работы над поиском возник вопрос с реализацией алгоритма
фильтрации подсказок по вхождению. Я пришел к выводу, что нет необходимости
в реализации какого-либо сложного алгоритма поиска подстроки,
так как в истории хранится всего 20 значений, и на таком объеме скорость работы алгоритма несущественна.
Я использовал просто ` String.prototype.includes() `
3. Изначально использование state-менеджера мне показалось излишним, так как 
не было необходимости передавать данные между страницами или больше, чем на один уровень.
Соответственно, в работе он практически не используется. Однако во 
время работы над авторизацией я понял, использовать состояние авторизации и менять его необходимо совершенно в разных местах.
Поэтому, чтобы избежать костылей, для данной задачи я все таки использовал Redux
